There were two main changes that had to be made to our protocol from part 1, including the use of digital signatures 
to protect the integrity of our messages and only using a shared key, rather than having the client generate their own 
additional public/private key pair. Our original protocol used nonces to try to ensure the integrity of messages, but
this was incorrect and the use of digital signatures in this case will ensure the integrity of our messages. Additionally,
originally we had the client generate their own public/private key to use for the initial request sent and then the server
would generate a shared key to use for all future sessions. While this will technically work, we changed the protocol
in this part to be optimized so only a session key is generated by the client, which is shared with the server through
the server's public key. Our updated protocol is listed below.

Let KS refer to the server’s public key and ks refer to the server’s private key, K_AS is the shared key between A and the server, kds/Kds is A’s digital signature. 

Server should maintain a binding table for A including Kds, UserID, and tod

1) A → Server: A, {m, sig}_KAS, {KAS}_KS 
    m := A, UserID, LOGIN, tod, Kds
    sig = kds-Sign(m)
    tod = current time/date
    Kds = A’s digital signature
    Server decrypts KAS with ks
    Server decrypts m, sig with KAS
    Server verifies m, sig = m, Kds
    Server verifies plaintext A on outside is equal to m.A from encrypted message
    tableA.tod < m.tod < currentTime()
    If userId is currently associated with another running session, it rejects the request. Returns SUCCESS otherwise. 

2) Server → A: S, {m’, sig’}KAS
    m’ := A, m.UserID, LOGIN, m.tod, SUCCESS
    So m.tod = m’.tod right
    sig’ = ks-Sign(m)
    Client decrypts m’, sig’ with KAS
    Client verifies signatures with KS
    Client verifies A, UserID, LOGIN, m’.tod match the fields they originally sent out

3) A → Server: A, {m, sig}KAS
    m := A, UserID, operation + relevant fields, tod, Kds
    sig = kds-Sign(m)
    Same authentication as for msg 1

4) Server -> A: S, {m’, sig’}K_AS
    m’ := A, m.UserID, response, m.tod

Repeat steps 3 and 4 as many times as desired.

5) A → Server: A, {m, sig}KAS
    m := A, UserID, LOGOUT, tod, Kds
    sig = kds-Sign(m)
    Server will perform validity check on LOGOUT request. If r or userId does not match the ones from LOGIN, rejects the request. Client removes KAS, server removes public and private keys from binding table

6) Server -> A: S, {m’, sig’}K_AS
    m’ := A, m.UserID, response, m.tod
    END OF SESSION